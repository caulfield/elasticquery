{"name":"Elasticquery","tagline":"User oriented elastic search query generator","body":"# Elasticquery\r\n\r\n[![Gem Version](https://badge.fury.io/rb/elasticquery.svg)](http://badge.fury.io/rb/elasticquery)\r\n[![Build Status](https://travis-ci.org/caulfield/elasticquery.svg?branch=master)](https://travis-ci.org/caulfield/elasticquery)\r\n[![Code Climate](https://codeclimate.com/github/caulfield/elasticquery/badges/gpa.svg)](https://codeclimate.com/github/caulfield/elasticquery)\r\n[![Test Coverage](https://codeclimate.com/github/caulfield/elasticquery/badges/coverage.svg)](https://codeclimate.com/github/caulfield/elasticquery)\r\n\r\nA module for elasticsearch-rails [libraries][elasticsearch_rails] like as user-friendly query generator.\r\n\r\n## Abstract\r\n\r\nElastic query ruby DSL is not a fresh idea. `elasticsearch-rails` has fully flexible language and recommends to use json generators for building complex queries. I hope, in most cases you don't need full complex setup. Elasticquery going to process your form parameters and build valid query using `Filters` and `Queries` elastic query methods. All rules are joined by `AND` condition, invalid or blank rules are ignored.\r\n\r\nElasticquery supports `term` (usable with  HTML `select` tag), `range`, `exists` and `missing`. `multi_match` query for simple index searching. All filters and queries are configurable. You are able to inherit your forms(`Elasticquery::Base objects`) and use chains event directly within your models.\r\n\r\n**Elasticquery is in active development. I recommend to use it CAREFULLY for production**\r\n\r\n## Installation\r\n\r\nTo install using [Bundler][bundler] grab the latest stable version:\r\n\r\n```ruby\r\ngem 'elasticquery'\r\n```\r\nTo manually install `elasticquery` via [Rubygems][rubygems] simply gem install:\r\n\r\n```bash\r\ngem install elasticquery\r\n```\r\n\r\n## Getting Started\r\n### First instruction\r\n\r\nElasticquery was designed to be customized as you need to. Providing simple methods it allows you to build flexible queries using [Elastic Query DSL][elastic_query_dsl]\r\n\r\n```ruby\r\nclass MyQuery < Elasticquery::Base\r\n  filtered do |params|\r\n    filters do\r\n      term \"user.id\" => params[:user_id]\r\n      range.not :age, gte: 18\r\n    end\r\n    queries do\r\n      multi_match params[:query]\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n```ruby\r\nquery = MyQuery.new query: 'i typed', user_id: 5\r\nquery.build # => query for elastic\r\nArticle.search query.build # => returns result \r\n```\r\n\r\n## Currently you have\r\n### Filters\r\n  [Term][es_term]\r\n\r\n\r\n  ```ruby\r\n  # Simple one term filter\r\n  term category: 'Rock'\r\n\r\n  # _cache option support\r\n  term category: 'Soul', _cache: false\r\n\r\n  # Blank values are skipped. This query returns all records\r\n  term name: \" \"\r\n  ```\r\n  [Terms][es_terms]\r\n\r\n\r\n  ```ruby\r\n  # Standard terms options\r\n  terms a: 1, b: 2\r\n\r\n  # Skip empty values\r\n  terms a: 1, b: \"\" # => {a: 1} wil be passed\r\n\r\n  # Blank terms are skipped\r\n  terms a: \"\", b: nil # => match_all will be executed\r\n\r\n  # _cache and execution support\r\n  terms a: 1, b: 2, _cache: false, execution: \"or\"\r\n\r\n  # where alias. Usable in chain calls\r\n  where a: 1, b: 2, c: 3\r\n  ```\r\n  [Range][es_range]\r\n\r\n\r\n  ```ruby\r\n  # One side range\r\n  range :age, gte: 18\r\n\r\n  # Double sides range\r\n  range :volume, gte: 1, lte: 100\r\n\r\n  # _cache and execution options support\r\n  range :volume, gte: 1, lte: 100, _cache: true, execution: \"fielddata\"\r\n  ```\r\n  [Exists][es_exists]\r\n  [Missing][es_missing]\r\n\r\n\r\n  ```ruby\r\n  # Field existence check\r\n  exists \"last_name\"\r\n  missing \"last_name\"\r\n\r\n  # Blank value skipped\r\n  exists \"\"\r\n  missing \"\"\r\n\r\n  # Has with alias\r\n  with 'first_name'\r\n  without 'first_name'\r\n  ```\r\n  [Not][es_not]\r\n\r\n\r\n  ```ruby\r\n  # Blank values are skipped. This query returns all records\r\n  range.not :age, lte: ' ', gte: nil\r\n\r\n  # Term exclusion\r\n  term.not category: 'Rap'\r\n\r\n  # Terms exclusion\r\n  terms.not category: 'Rap', name: \"Guf\"\r\n\r\n  # 'Exists not' uses missing\r\n  with.not #=> returns missing filter\r\n  ```\r\n\r\nAll filters are joined by **AND** filter.\r\n## Queries\r\n  [MultiMatch][es_search]\r\n\r\n\r\n  ```ruby\r\n  # Simple all fields search in your index\r\n  multi_match 'developers'\r\n\r\n  # The same as above\r\n  multi_match 'developers', fields: \"_all\", operator: \"and\", type: \"best_fields\"\r\n\r\n  # Configure fields\r\n  multi_match 'Jordan', fields: ['first_name', 'last_name'], operator: \"or\"\r\n\r\n  # Blank values are skipped. This query returns all records\r\n  multi_match ''\r\n\r\n  # Alias as search\r\n  search 'Hello!'\r\n  ```\r\n\r\n### Extended instruction\r\nThere are multiple ways to organize your query, using chaining calls, or custom filters.\r\n\r\n- Chain calls\r\n```ruby\r\nPeopleQuery.new.queries.multi_match('hi', operator: :or).filters.term(age: 21).build # => returns hash\r\nQuery.new.queries./queries-chain/.filters./filters-chain/\r\n```\r\n\r\n- Class methods\r\n\r\n```ruby\r\nclass PeopleQuery < Elasticquery::Base\r\n  filtered do |params|\r\n    filters do\r\n      range :age, lte: prepare_age(params[:max_age])\r\n    end\r\n  end\r\n\r\n  protected\r\n\r\n  def prepare_age(param)\r\n    param.to_i\r\n  end\r\nend\r\nPeopleQuery.build(max_age: '42') # => result\r\n```\r\n\r\n- Multiple `filtered` blocks\r\n\r\n```ruby\r\nclass ChildQuery < Elasticquery::Base\r\n  filtered do |params|\r\n    filters do\r\n      term :'category.id' => params[:category_id]\r\n    end\r\n  end\r\n\r\n  filtered do |params|\r\n    filters do\r\n      term :'author.id' => User.find(params[:user_id]).name\r\n    end\r\n  end\r\nend\r\nChildQuery.build({user_id: 1, category_id: 14}) => returns both user and category filters\r\n```\r\n\r\n- Query inheritance\r\n\r\n```ruby\r\nclass ParentQuery < Elasticquery::Base\r\n  filtered do |params|\r\n    filters do\r\n      term :'category.id' => params[:category_id]\r\n    end\r\n  end\r\nend\r\n\r\nclass ChildQuery < ParentQuery\r\n  filtered do |params|\r\n    filters do\r\n      term :'author.id' => User.find(params[:user_id]).name\r\n    end\r\n  end\r\nend\r\n\r\nChildQuery.build({user_id: 1, category_id: 14}) => # the same as in previous example\r\n```\r\n\r\n- Elasticsearch::Model support with `es` shortcut\r\n\r\n```ruby\r\nclass Article\r\n  include Elasticsearch::Model\r\n  extend Elasticquery::Es\r\nend\r\n\r\nArticle.es.filters.term(user_id: 12).with(\"published_at\").queries.search(\"Verge\").results # => collection of \"hits\"\r\nArticle.es.filters.term(user_id: 12).with(\"published_at\").queries.search(\"Verge\").records # => collection of records from db\r\n```\r\n\r\n[elasticsearch_rails]: https://github.com/elasticsearch/elasticsearch-rails\r\n[demo]: http://elasticquery-demo.herokuapp.com\r\n[bundler]: http://bundler.io/\r\n[rubygems]: https://rubygems.org/\r\n[es_term]: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-term-filter.html\r\n[es_terms]: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-terms-filter.html\r\n[es_not]: https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-not-filter.html\r\n[es_exists]: https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-filter.html\r\n[es_missing]: https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-missing-filter.html\r\n[es_search]: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html\r\n[es_range]: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-range-query.html\r\n[elastic_query_dsl]: https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\r\n","google":"UA-52951438-1","note":"Don't delete this file! It's used internally to help with page regeneration."}